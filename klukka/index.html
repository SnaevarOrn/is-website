<!DOCTYPE html>
<html lang="is" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ís.is — Klukka</title>

  <!-- Favicons -->
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <link rel="icon" href="/favicon.png" sizes="32x32">
  <link rel="icon" href="/favicon.png" sizes="16x16">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">

  <!-- Apply theme ASAP (prevents flash) -->
  <script>
    (function(){
      const t = localStorage.getItem('theme');
      document.documentElement.setAttribute('data-theme', t === 'light' ? 'light' : 'dark');
    })();
  </script>

  <style>
    :root{
      --bg:#0b0c0f;
      --panel:#12141a;
      --panel2:#0f1116;
      --line:rgba(255,255,255,.10);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.70);
      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --btn:#f2f2f2;
      --btnText:#0b0c0f;
    }
    html[data-theme="light"]{
      --bg:#f6f7f9;
      --panel:#ffffff;
      --panel2:#ffffff;
      --line:rgba(0,0,0,.10);
      --text:rgba(0,0,0,.88);
      --muted:rgba(0,0,0,.58);
      --shadow: 0 18px 60px rgba(0,0,0,.10);
      --btn:#111318;
      --btnText:#ffffff;
    }

    *{ box-sizing:border-box; margin:0; padding:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    body{
      min-height:100vh;
      background: var(--bg);
      color: var(--text);
      display:flex;
      flex-direction:column;
    }

    header{
      position:sticky; top:0; z-index:30;
      background: color-mix(in srgb, var(--panel2) 92%, transparent);
      border-bottom: 1px solid var(--line);
      backdrop-filter: blur(10px);
    }
    .hdr{
      max-width: 760px;
      margin: 0 auto;
      padding: 12px 14px;
      display:grid;
      grid-template-columns: 44px 1fr 44px;
      align-items:center;
      gap: 10px;
    }
    .back{
      width:44px; height:44px;
      border:1px solid var(--line);
      background: transparent;
      border-radius: 12px;
      display:flex; align-items:center; justify-content:center;
      cursor:pointer;
      color: var(--text);
      text-decoration:none;
      font-weight: 900;
      user-select:none;
    }
    .back:active{ transform: translateY(1px); }
    .hdr-date{
      text-align:center;
      font-weight: 850;
      letter-spacing:.2px;
      font-size: 15px;
      user-select:none;
      color: var(--text);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .ghost{ width:44px; height:44px; opacity:0; pointer-events:none; }

    main{
      flex:1;
      display:flex;
      justify-content:center;
      padding: 18px 16px 18px;
    }
    .wrap{
      width: min(760px, 100%);
      display:flex;
      flex-direction:column;
      align-items:center;
      padding-top: 6px;
    }
    .card{
      width: min(560px, 100%);
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 22px;
      padding: 16px 14px 14px;
      box-shadow: var(--shadow);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 12px;
    }

    /* Digital (top) */
    .digitalTime{
      font-variant-numeric: tabular-nums;
      letter-spacing: .9px;
      font-weight: 900;
      font-size: 46px;
      padding: 10px 16px;
      border-radius: 18px;
      border: 1px solid var(--line);
      background: color-mix(in srgb, var(--panel2) 85%, transparent);
      box-shadow: inset 0 0 0 6px color-mix(in srgb, var(--text) 3%, transparent);
      text-align:center;
      min-width: 270px;
    }

    /* Analog (middle) */
    .analog{
      width: 270px;
      height: 270px;
      border-radius: 50%;
      border: 1px solid var(--line);
      background: color-mix(in srgb, var(--panel2) 85%, transparent);
      box-shadow: inset 0 0 0 8px color-mix(in srgb, var(--text) 3%, transparent);
      position: relative;
      margin: 2px 0;
    }
    .center-dot{
      position:absolute;
      left:50%; top:50%;
      width:10px; height:10px;
      border-radius:50%;
      background: color-mix(in srgb, var(--text) 80%, transparent);
      transform: translate(-50%,-50%);
      z-index: 10;
      box-shadow: 0 0 0 4px color-mix(in srgb, var(--text) 8%, transparent);
    }
    .hand{
      position:absolute;
      left:50%; top:50%;
      transform-origin: 50% 100%;
      transform: translate(-50%,-100%) rotate(0deg);
      border-radius: 999px;
      background: color-mix(in srgb, var(--text) 85%, transparent);
    }
    .hand.hour{ width:8px; height:80px; opacity:.92; }
    .hand.min { width:6px; height:108px; opacity:.88; }
    .hand.sec { width:2px; height:124px; opacity:.70; }

    .ticks{ position:absolute; inset: 12px; border-radius: 50%; pointer-events:none; }
    .tick{
      position:absolute;
      left:50%; top:50%;
      width:2px; height:10px;
      background: color-mix(in srgb, var(--text) 20%, transparent);
      transform-origin: 50% 120px;
      transform: translate(-50%,-120px) rotate(0deg);
      border-radius:2px;
    }
    .tick.big{
      height:14px;
      background: color-mix(in srgb, var(--text) 28%, transparent);
    }

    /* Status pill (bottom) */
    .pill{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 8px 12px;
      background: color-mix(in srgb, var(--panel2) 70%, transparent);
      color: var(--muted);
      font-size: 12px;
    }
    .dot{
      width:8px; height:8px; border-radius:50%;
      background: color-mix(in srgb, var(--text) 35%, transparent);
      opacity:.95;
    }
    .dot.ok{ background:#2ecc71; }
    .dot.warn{ background:#f1c40f; }
    .dot.bad{ background:#e74c3c; }

    @media (max-width:420px){
      .analog{ width: 240px; height: 240px; }
      .digitalTime{ font-size: 40px; min-width: 250px; }
    }
  </style>
</head>

<body>
  <header>
    <div class="hdr">
      <a class="back" href="/" aria-label="Til baka">←</a>
      <div class="hdr-date" id="hdrDate">—</div>
      <div class="ghost" aria-hidden="true"></div>
    </div>
  </header>

  <main>
    <div class="wrap">
      <div class="card">
        <div class="digitalTime" id="digitalTime">--:--:--</div>

        <div class="analog" aria-label="Analog klukka">
          <div class="ticks" id="ticks"></div>
          <div class="hand hour" id="hHand"></div>
          <div class="hand min" id="mHand"></div>
          <div class="hand sec" id="sHand"></div>
          <div class="center-dot"></div>
        </div>

        <div class="pill">
          <span class="dot" id="syncDot"></span>
          <span id="syncText">Tími: net (Reykjavík)</span>
        </div>
      </div>
    </div>
  </main>

  <script>
    // ---------------------------
    // Real net-sync + smooth drift correction (PLL-ish)
    // ---------------------------
    // We sample WorldTimeAPI regularly, estimate offset at midpoint of request,
    // estimate drift (clock rate error), and SLEW corrections smoothly:
    // - Offset is slewed with max ms per second (no jumps)
    // - Rate correction (scale) is low-pass filtered (ppm-level)
    //
    // If network fails, we keep running on last good model and show warning/bad.
    // ---------------------------

    const TZ_URL = 'https://worldtimeapi.org/api/timezone/Atlantic/Reykjavik';

    const syncDot  = document.getElementById('syncDot');
    const syncText = document.getElementById('syncText');

    function setStatus(kind, txt){
      syncDot.classList.remove('ok','warn','bad');
      syncDot.classList.add(kind);
      syncText.textContent = txt;
    }

    // Model: correctedTime = baseNetMs + (localPerfNow - basePerfNow) * scale + offsetSlew
    // where scale ~= 1 + drift (e.g. 20ppm -> 1.00002)
    let basePerf = performance.now();
    let baseNet  = Date.now();     // initial guess = local wall clock
    let scale    = 1.0;            // rate correction
    let targetScale = 1.0;

    // Offset slewing (ms) toward targetOffset (ms)
    let offsetMs = 0;
    let targetOffsetMs = 0;

    // Sync bookkeeping
    let lastGoodSyncPerf = null;
    let lastGoodOffset = null;
    let lastGoodSyncAgeMs = 0;
    let consecutiveFails = 0;

    // Slew limits (feel free to tweak)
    const MAX_OFFSET_SLEW_MS_PER_S = 8;     // max 8ms per second correction (smooth, no jumps)
    const SCALE_SLEW_PER_S = 2e-6;          // max scale change per second (~2 ppm/s)

    function correctedNowMs(){
      const p = performance.now();
      const elapsed = p - basePerf; // ms
      // baseNet already includes base offset at sync moment; offsetMs is a slowly changing extra offset.
      return baseNet + elapsed * scale + offsetMs;
    }

    function isFiniteNum(x){ return Number.isFinite(x) && !Number.isNaN(x); }

    async function sampleNetTime(){
      const t0p = performance.now();
      const t0w = Date.now();

      const res = await fetch(TZ_URL, { cache: 'no-store' });

      const t1p = performance.now();
      const t1w = Date.now();

      if(!res.ok) throw new Error('HTTP ' + res.status);
      const data = await res.json();

      // Parse server-provided datetime
      const serverMs = new Date(data.datetime).getTime();
      if(!isFiniteNum(serverMs)) throw new Error('bad datetime');

      // Estimate midpoint local wall time (reduces latency bias)
      const midWall = (t0w + t1w) / 2;
      const rtt = (t1p - t0p);

      // Offset sample: how much we must add to local wall clock to match server time at midpoint
      const offsetSample = serverMs - midWall;

      return { offsetSample, rtt, tMidPerf: (t0p + t1p)/2 };
    }

    function applySync(offsetSample, rtt, tMidPerf){
      // Weight based on RTT: lower RTT -> higher weight
      // Clamp RTT influence so we don't go wild on mobile
      const rttClamped = Math.min(Math.max(rtt, 20), 2000);
      const w = 1 / (1 + (rttClamped / 200)); // ~0.91 at 20ms, ~0.17 at 1000ms

      // Estimate drift from change in offset over time (offset slope)
      if(lastGoodSyncPerf !== null && lastGoodOffset !== null){
        const dt = (tMidPerf - lastGoodSyncPerf) / 1000; // seconds
        if(dt > 0.5){
          const dOffset = (offsetSample - lastGoodOffset); // ms
          const drift = (dOffset / (dt * 1000)); // ms per ms => dimensionless (≈ ppm)
          // Convert to scale target
          const newTargetScale = 1 + drift;
          if(isFiniteNum(newTargetScale)){
            // Low-pass filter into targetScale (weighted)
            targetScale = targetScale + (newTargetScale - targetScale) * (0.25 * w);
          }
        }
      }

      // Target offset: offsetSample relative to our model's raw local wall time.
      // Our model uses performance clock + baseNet, so set a target offset correction:
      targetOffsetMs = targetOffsetMs + (offsetSample - targetOffsetMs) * (0.6 * w);

      // Anchor base at the sync midpoint to keep numbers stable
      // We want correctedNow(mid) == serverMs (approximately).
      // serverMs ≈ midWall + offsetSample.
      const midWall = Date.now() + (tMidPerf - performance.now()); // approx wall at that perf time
      const serverAtMid = midWall + offsetSample;

      basePerf = tMidPerf;
      baseNet  = serverAtMid; // includes the offset at mid

      lastGoodSyncPerf = tMidPerf;
      lastGoodOffset = offsetSample;
      consecutiveFails = 0;
    }

    function tickSlews(dtSeconds){
      // Slew offset toward targetOffsetMs with max rate
      const maxStep = MAX_OFFSET_SLEW_MS_PER_S * dtSeconds;
      const diff = targetOffsetMs - offsetMs;
      const step = Math.max(-maxStep, Math.min(maxStep, diff));
      offsetMs += step;

      // Slew scale toward targetScale with max rate
      const maxScaleStep = SCALE_SLEW_PER_S * dtSeconds;
      const sd = targetScale - scale;
      const sstep = Math.max(-maxScaleStep, Math.min(maxScaleStep, sd));
      scale += sstep;
    }

    async function syncLoop(){
      try{
        const { offsetSample, rtt, tMidPerf } = await sampleNetTime();
        applySync(offsetSample, rtt, tMidPerf);
        setStatus('ok', 'Tími: net (Reykjavík)');
      }catch(err){
        consecutiveFails++;
        // If we recently had a good sync, treat as warning; else bad.
        if(lastGoodSyncPerf !== null){
          setStatus('warn', 'Tími: net (Reykjavík) — óstöðugt net');
        }else{
          setStatus('bad', 'Tími: tæki (net náðist ekki)');
        }
      }finally{
        // Resync cadence: fast after failures, slower when stable
        const base = (consecutiveFails === 0) ? 60_000 : 10_000; // 60s stable, 10s retry
        const jitter = Math.random() * 8000; // avoid thundering herd
        setTimeout(syncLoop, base + jitter);
      }
    }

    // ---------------------------
    // UI rendering
    // ---------------------------
    const hHand = document.getElementById('hHand');
    const mHand = document.getElementById('mHand');
    const sHand = document.getElementById('sHand');
    const digitalTime = document.getElementById('digitalTime');
    const hdrDate = document.getElementById('hdrDate');

    function pad(n){ return String(n).padStart(2,'0'); }

    // ticks
    (function buildTicks(){
      const ticks = document.getElementById('ticks');
      for(let i=0;i<60;i++){
        const t = document.createElement('div');
        t.className = 'tick' + (i%5===0 ? ' big' : '');
        t.style.transform = `translate(-50%,-120px) rotate(${i*6}deg)`;
        ticks.appendChild(t);
      }
    })();

    let lastPerf = performance.now();
    let lastHeaderDayKey = '';

    function render(){
      const nowPerf = performance.now();
      const dt = (nowPerf - lastPerf) / 1000;
      lastPerf = nowPerf;

      if(dt > 0 && dt < 0.5) tickSlews(dt);

      const ms = correctedNowMs();
      const d = new Date(ms);

      // Digital time
      digitalTime.textContent = `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;

      // Header date (update only when day changes, avoids extra work)
      const dayKey = `${d.getFullYear()}-${d.getMonth()}-${d.getDate()}`;
      if(dayKey !== lastHeaderDayKey){
        lastHeaderDayKey = dayKey;
        hdrDate.textContent = d.toLocaleDateString('is-IS', { weekday:'long', year:'numeric', month:'long', day:'numeric' });
      }

      // Analog hands (smooth seconds)
      const sec = d.getSeconds() + d.getMilliseconds()/1000;
      const min = d.getMinutes() + sec/60;
      const hr  = (d.getHours()%12) + min/60;

      sHand.style.transform = `translate(-50%,-100%) rotate(${sec*6}deg)`;
      mHand.style.transform = `translate(-50%,-100%) rotate(${min*6}deg)`;
      hHand.style.transform = `translate(-50%,-100%) rotate(${hr*30}deg)`;

      requestAnimationFrame(render);
    }

    // Start
    (function init(){
      // Start syncing immediately, and render immediately.
      // If net is blocked, it gracefully falls back (and keeps smoothing anyway).
      syncLoop();
      requestAnimationFrame(render);
    })();
  </script>
</body>
</html>