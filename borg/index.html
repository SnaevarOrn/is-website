<!doctype html>
<html lang="is">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>B√¶ir ‚Äî giska√∞u sta√∞setningu</title>
  <style>
    :root{
      --bg:#07090f;
      --text:#e9eefc;
      --muted:#9aa6c3;
      --line:rgba(255,255,255,.10);
      --accent:#7dd3fc;
      --good:#86efac;
      --bad:#fca5a5;
      --shadow: 0 18px 50px rgba(0,0,0,.45);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 700px at 50% -10%, rgba(125,211,252,.15), transparent 55%),
                  radial-gradient(900px 600px at 20% 20%, rgba(167,139,250,.12), transparent 60%),
                  var(--bg);
      color:var(--text);
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
    }

    /* Top site header (back + prototype) */
    .siteHeader{
      width:min(1100px, 100%);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:10px;
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(0,0,0,.18);
      box-shadow: var(--shadow);
    }
    .siteHeader a{
      color: var(--text);
      text-decoration:none;
      font-weight:800;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .siteHeader .right{
      color: var(--muted);
      font-weight:700;
      white-space:nowrap;
    }

    .wrap{
      width:min(1100px, 100%);
    }

    .card{
      width:100%;
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border: 1px solid var(--line);
      border-radius: 18px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .top{
      padding:14px;
      display:grid;
      grid-template-columns: 1.6fr 1fr;
      gap:12px;
      border-bottom:1px solid var(--line);
      background: rgba(0,0,0,.12);
    }
    @media (max-width: 900px){
      .top{ grid-template-columns: 1fr; }
    }

    .prompt{
      padding:12px;
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(0,0,0,.18);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      min-height:64px;
    }
    .prompt .left{ min-width:0; }
    .label{
      font-size:12px;
      color:var(--muted);
      margin-bottom:6px;
    }
    .city{
      font-size:22px;
      font-weight:800;
      letter-spacing:.2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .chipStack{
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap:6px;
      flex:0 0 auto;
    }
    .chip{
      font-size:12px;
      color:var(--muted);
      border:1px solid var(--line);
      padding:6px 10px;
      border-radius:999px;
      background: rgba(0,0,0,.15);
      white-space:nowrap;
    }
    .chipScore{
      color: rgba(233,238,252,.92);
      border-color: rgba(125,211,252,.25);
      background: rgba(125,211,252,.08);
      font-weight:800;
    }

    .toast{
      padding:12px;
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(0,0,0,.18);
      min-height: 64px;
    }
    .toast .t{ font-size:12px; color:var(--muted); }
    .toast .m{ margin-top:6px; font-size:14px; line-height:1.35; }
    .good{ color: var(--good); font-weight:900; }
    .bad{ color: var(--bad); font-weight:900; }

    button{
      appearance:none;
      border:1px solid var(--line);
      background: rgba(0,0,0,.20);
      color: var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:800;
      transition: transform .05s ease, background .15s ease;
      user-select:none;
    }
    button:hover{ background: rgba(255,255,255,.06); }
    button:active{ transform: translateY(1px); }
    button:disabled{ opacity:.55; cursor:not-allowed; }
    .primary{
      border-color: rgba(125,211,252,.35);
      background: rgba(125,211,252,.10);
    }

    .mapWrap{
      position:relative;
      height: min(72vh, 700px);
      min-height: 420px;
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      overflow:hidden;
    }
    .mapViewport{
      position:absolute;
      inset:0;
      cursor: grab;
      touch-action: none; /* pan + pinch */
      background: rgba(0,0,0,.10);
    }
    .mapViewport:active{ cursor: grabbing; }

    .mapLayer{
      position:absolute;
      left:0; top:0;
      transform-origin: 0 0;
      will-change: transform;
    }
    .mapImg{
      display:block;
      -webkit-user-drag:none;
      user-select:none;
      pointer-events:none;
      max-width:none;
    }

    /* Markers */
    .marker{
      position:absolute;
      width:16px; height:16px;
      border-radius:50%;
      transform: translate(-50%, -50%);
      border: 2px solid rgba(255,255,255,.9);
      box-shadow: 0 10px 22px rgba(0,0,0,.45);
      pointer-events:none;
    }
    .marker.cityDone{ background: rgba(125,211,252,.95); }
    .marker.tap{ background: rgba(255,255,255,.20); border-color: rgba(255,255,255,.75); box-shadow: 0 10px 22px rgba(0,0,0,.25); }

    /* Overlay zoom controls (right) */
    .overlay{
      position:absolute;
      right:12px;
      top:12px;
      display:flex;
      flex-direction:column;
      gap:8px;
      z-index: 5;
    }
    .overlay .row{ display:flex; gap:8px; justify-content:flex-end; }
    .small{ padding:8px 10px; font-size:13px; border-radius:10px; }

    /* Tiny confirm bubble near tap */
    .confirmBubble{
      position:absolute;
      z-index: 10;
      display:none;
      min-width: 220px;
      max-width: 260px;
      padding:10px;
      border:1px solid var(--line);
      border-radius:14px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.35));
      box-shadow: var(--shadow);
      backdrop-filter: blur(6px);
    }
    .confirmBubble.show{ display:block; }
    .confirmBubble .t{
      font-size:12px;
      color:var(--muted);
      margin-bottom:6px;
    }
    .confirmBubble .m{
      font-size:13px;
      line-height:1.35;
      margin-bottom:10px;
    }
    .confirmBubble .actions{
      display:flex;
      gap:8px;
      justify-content:flex-end;
    }
    .confirmBubble .mini{
      padding:8px 10px;
      font-size:13px;
      border-radius:10px;
    }
    .confirmBubble:before{
      content:"";
      position:absolute;
      left:12px;
      top:-7px;
      width:12px; height:12px;
      transform: rotate(45deg);
      background: rgba(0,0,0,.28);
      border-left:1px solid var(--line);
      border-top:1px solid var(--line);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="siteHeader">
      <!-- Still there, you can change href as needed -->
      <a href="../index.html">‚Üê Til baka</a>
      <div class="right">√≠s.is ‚Äî pr√≥t√≥t√Ωpa</div>
    </div>

    <div class="card">
      <div class="top">
        <div class="prompt">
          <div class="left">
            <div class="label">√ùttu √° korti√∞ til a√∞ velja sta√∞setningu</div>
            <div class="city" id="cityName">‚Äî</div>
          </div>
          <div class="chipStack">
            <div class="chip" id="roundChip">Umfer√∞ 1/5</div>
            <div class="chip chipScore" id="scoreChip">Samtals: 0</div>
          </div>
        </div>

        <div class="toast" id="toast">
          <div class="t">Ni√∞ursta√∞a</div>
          <div class="m" id="toastMsg">√ùttu √° korti√∞ til a√∞ velja sta√∞setningu.</div>
        </div>
      </div>

      <div class="mapWrap" id="mapWrap">
        <div class="overlay">
          <div class="row">
            <button class="small" id="zoomIn">+</button>
            <button class="small" id="zoomOut">‚àí</button>
            <button class="small" id="centerBtn">Mi√∞ja</button>
          </div>
        </div>

        <!-- tiny confirm bubble -->
        <div class="confirmBubble" id="confirmBubble" aria-hidden="true">
          <div class="t">Sta√∞festa?</div>
          <div class="m">Skr√° gisk og fara sj√°lfkrafa √≠ n√¶sta b√¶.</div>
          <div class="actions">
            <button class="mini" id="cancelGuessBtn">H√¶tta vi√∞</button>
            <button class="mini primary" id="confirmGuessBtn">Sta√∞festa</button>
          </div>
        </div>

        <div class="mapViewport" id="viewport" aria-label="Kort">
          <div class="mapLayer" id="layer">
            <img id="mapImg" class="mapImg" alt="Kort af √çslandi" />
            <!-- temporary tap marker (shows where you tapped) -->
            <div class="marker tap" id="tapMarker" style="display:none;"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const MAP_SRC = "./assets/iceland_map.png";

  const CITIES = [
    { name: "Reykjav√≠k",   x: 0.28, y: 0.70 },
    { name: "√çsafj√∂r√∞ur",  x: 0.20, y: 0.33 },
    { name: "Akureyri",    x: 0.52, y: 0.34 },
    { name: "Sau√∞√°rkr√≥kur",    x: 0.42, y: 0.34 },
    { name: "Egilssta√∞ir", x: 0.78, y: 0.48 },
    { name: "H√∂fn √≠ Hornafir√∞i", x: 0.73, y: 0.80 },
  ];

  const MAX_DIST_PX = 380;
  const MIN_SCALE = 1;  // ekki minnka inn√≠ boxinu
  const MAX_SCALE = 6;

  let idx = 0;
  let total = 0;
  let guessed = false;

  let scale = 1;
  let tx = 0, ty = 0;

  // Pointer tracking for pan + pinch
  const pointers = new Map();
  let panPointerId = null;
  let isPanning = false;
  let panStart = { x:0, y:0, tx:0, ty:0 };

  let isPinching = false;
  let pinchStart = { dist:0, scale:1, midVX:0, midVY:0, tx:0, ty:0 };

  // Pending guess (for confirm bubble)
  let pendingGuessN = null;
  let pendingTapVX = 0, pendingTapVY = 0; // viewport coords
  let pendingWasClick = false;

  // DOM
  const mapImg = document.getElementById("mapImg");
  const viewport = document.getElementById("viewport");
  const layer = document.getElementById("layer");
  const mapWrap = document.getElementById("mapWrap");

  const cityName = document.getElementById("cityName");
  const roundChip = document.getElementById("roundChip");
  const scoreChip = document.getElementById("scoreChip");
  const toastMsg = document.getElementById("toastMsg");

  const tapMarker = document.getElementById("tapMarker");

  const zoomIn = document.getElementById("zoomIn");
  const zoomOut = document.getElementById("zoomOut");
  const centerBtn = document.getElementById("centerBtn");

  const confirmBubble = document.getElementById("confirmBubble");
  const confirmGuessBtn = document.getElementById("confirmGuessBtn");
  const cancelGuessBtn = document.getElementById("cancelGuessBtn");

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function imageSize(){ return { w: mapImg.naturalWidth || 1, h: mapImg.naturalHeight || 1 }; }

  function clampTransform(){
    const rect = viewport.getBoundingClientRect();
    const vw = rect.width, vh = rect.height;
    const s = imageSize();
    const iw = s.w * scale;
    const ih = s.h * scale;

    if (iw <= vw) tx = (vw - iw) / 2;
    else tx = clamp(tx, vw - iw, 0);

    if (ih <= vh) ty = (vh - ih) / 2;
    else ty = clamp(ty, vh - ih, 0);
  }

  function applyTransform(){
    clampTransform();
    layer.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
  }

  function center(){
    const s = imageSize();
    const rect = viewport.getBoundingClientRect();
    const vw = rect.width, vh = rect.height;
    tx = (vw - s.w * scale) / 2;
    ty = (vh - s.h * scale) / 2;
    applyTransform();
  }

  function pxFromNormalized(p){
    const s = imageSize();
    return { x: p.x * s.w, y: p.y * s.h };
  }

  function normalizedFromClient(clientX, clientY){
    const rect = viewport.getBoundingClientRect();
    const vx = clientX - rect.left;
    const vy = clientY - rect.top;
    const lx = (vx - tx) / scale;
    const ly = (vy - ty) / scale;
    const s = imageSize();
    return { x: lx / s.w, y: ly / s.h };
  }

  function scoreFromDistance(distPx){
    const t = 1 - clamp(distPx / MAX_DIST_PX, 0, 1);
    return Math.round(Math.pow(t, 1.6) * 100);
  }

  function setRound(){
    const c = CITIES[idx];
    cityName.textContent = c.name;
    roundChip.textContent = `Umfer√∞ ${idx+1}/${CITIES.length}`;
    scoreChip.textContent = `Samtals: ${total}`;
    guessed = false;
    toastMsg.textContent = "√ùttu √° korti√∞ til a√∞ velja sta√∞setningu.";
    hideConfirm();
    tapMarker.style.display = "none";
  }

  function addCityMarkerForCurrent(){
    const c = CITIES[idx];
    const truthPx = pxFromNormalized({ x: c.x, y: c.y });

    // ‚úÖ hanga eftir: b√Ωr til n√Ωjan marker sem ver√∞ur eftir √° layer
    const m = document.createElement("div");
    m.className = "marker cityDone";
    m.style.left = truthPx.x + "px";
    m.style.top  = truthPx.y + "px";
    layer.appendChild(m);
  }

  function hideConfirm(){
    confirmBubble.classList.remove("show");
    confirmBubble.setAttribute("aria-hidden", "true");
    pendingGuessN = null;
  }

  function showConfirmAt(vx, vy){
    // place bubble near tap inside mapWrap (clamped so it stays visible)
    const wrapRect = mapWrap.getBoundingClientRect();
    const viewRect = viewport.getBoundingClientRect();

    // bubble positioned relative to mapWrap
    confirmBubble.classList.add("show");
    confirmBubble.setAttribute("aria-hidden", "false");

    // preferred position: slightly right + down from tap
    const bubbleW = confirmBubble.offsetWidth || 240;
    const bubbleH = confirmBubble.offsetHeight || 110;

    const tapX = (viewRect.left + vx) - wrapRect.left;
    const tapY = (viewRect.top + vy) - wrapRect.top;

    let x = tapX + 12;
    let y = tapY + 12;

    // clamp inside wrap
    x = clamp(x, 10, wrapRect.width - bubbleW - 10);
    y = clamp(y, 10, wrapRect.height - bubbleH - 10);

    confirmBubble.style.left = x + "px";
    confirmBubble.style.top  = y + "px";

    // little arrow points "roughly" to tap (good enough)
    // (If you want pixel-perfect arrow aiming, we can do it later)
  }

  function finishGuess(guessN){
    const c = CITIES[idx];
    const truthN = { x: c.x, y: c.y };

    const guessPx = pxFromNormalized(guessN);
    const truthPx = pxFromNormalized(truthN);

    const distPx = Math.hypot(guessPx.x - truthPx.x, guessPx.y - truthPx.y);
    const pts = scoreFromDistance(distPx);

    total += pts;
    scoreChip.textContent = `Samtals: ${total}`;

    // ‚úÖ marker hangs on the city (truth)
    addCityMarkerForCurrent();

    const vibe = pts >= 70 ? "N√°l√¶gt!" : (pts >= 35 ? "Ekki sl√¶mt." : "√ûa√∞ er alltaf n√¶sta umfer√∞ üòÑ");
    toastMsg.innerHTML = `<span class="${pts>=70?'good':(pts>=35?'':'bad')}">${pts} stig</span> ‚Äî fjarl√¶g√∞ ~ ${Math.round(distPx)} px. ${vibe}`;

    guessed = true;
    hideConfirm();

    // auto-next after a short feedback
    setTimeout(() => goNext(), 650);
  }

  function goNext(){
    idx++;
    tapMarker.style.display = "none";
    if (idx >= CITIES.length){
      const avg = Math.round(total / CITIES.length);
      toastMsg.innerHTML = `<span class="good">Leik loki√∞!</span> Samtals: <b>${total}</b> stig (me√∞altal ${avg}).`;
      cityName.textContent = "‚Äî";
      roundChip.textContent = `Loki√∞ (${CITIES.length}/${CITIES.length})`;
      return;
    }
    setRound();
  }

  function zoomAt(factor, clientX, clientY){
    const rect = viewport.getBoundingClientRect();
    const vx = clientX - rect.left;
    const vy = clientY - rect.top;

    const newScale = clamp(scale * factor, MIN_SCALE, MAX_SCALE);
    if (newScale === scale) return;

    const lx = (vx - tx) / scale;
    const ly = (vy - ty) / scale;

    tx = vx - lx * newScale;
    ty = vy - ly * newScale;
    scale = newScale;

    applyTransform();
  }

  function zoomAtViewportPoint(newScale, vx, vy){
    newScale = clamp(newScale, MIN_SCALE, MAX_SCALE);
    if (newScale === scale) return;

    const lx = (vx - tx) / scale;
    const ly = (vy - ty) / scale;

    tx = vx - lx * newScale;
    ty = vy - ly * newScale;
    scale = newScale;

    applyTransform();
  }

  // ===== Pointer events: pan + pinch + tap =====
  viewport.addEventListener("pointerdown", (e) => {
    viewport.setPointerCapture(e.pointerId);
    pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

    // if confirm is open and user taps elsewhere: close (but don't break pinch)
    if (confirmBubble.classList.contains("show") && pointers.size === 1){
      // allow close on outside tap AFTER pointerup if it's a click; handled below
    }

    if (pointers.size === 2){
      const pts = [...pointers.values()];
      const dx = pts[1].x - pts[0].x;
      const dy = pts[1].y - pts[0].y;
      const dist = Math.hypot(dx, dy);

      const rect = viewport.getBoundingClientRect();
      const midVX = ((pts[0].x + pts[1].x) / 2) - rect.left;
      const midVY = ((pts[0].y + pts[1].y) / 2) - rect.top;

      isPinching = true;
      isPanning = false;
      panPointerId = null;
      pendingWasClick = false;

      pinchStart = { dist, scale, midVX, midVY, tx, ty };
      return;
    }

    if (!isPinching){
      panPointerId = e.pointerId;
      isPanning = true;
      pendingWasClick = true;
      panStart = { x: e.clientX, y: e.clientY, tx, ty };
    }
  });

  viewport.addEventListener("pointermove", (e) => {
    if (!pointers.has(e.pointerId)) return;
    pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

    if (isPinching && pointers.size >= 2){
      const pts = [...pointers.values()];
      const dx = pts[1].x - pts[0].x;
      const dy = pts[1].y - pts[0].y;
      const dist = Math.hypot(dx, dy);

      const ratio = dist / (pinchStart.dist || 1);
      const newScale = pinchStart.scale * ratio;

      tx = pinchStart.tx;
      ty = pinchStart.ty;
      scale = pinchStart.scale;
      zoomAtViewportPoint(newScale, pinchStart.midVX, pinchStart.midVY);

      pendingWasClick = false;
      return;
    }

    if (isPanning && e.pointerId === panPointerId){
      const dx = e.clientX - panStart.x;
      const dy = e.clientY - panStart.y;

      if (Math.hypot(dx, dy) > 6) pendingWasClick = false;

      tx = panStart.tx + dx;
      ty = panStart.ty + dy;
      applyTransform();
    }
  });

  viewport.addEventListener("pointerup", (e) => {
    if (!pointers.has(e.pointerId)) return;
    pointers.delete(e.pointerId);

    if (isPinching){
      if (pointers.size < 2){
        isPinching = false;
        if (pointers.size === 1){
          const remainingId = [...pointers.keys()][0];
          panPointerId = remainingId;
          isPanning = true;
          const p = pointers.get(remainingId);
          panStart = { x: p.x, y: p.y, tx, ty };
          pendingWasClick = false;
        }
      }
      return;
    }

    if (isPanning && e.pointerId === panPointerId){
      isPanning = false;
      panPointerId = null;

      if (pendingWasClick){
        const n = normalizedFromClient(e.clientX, e.clientY);

        // If tap is outside image => just message
        if (!(n.x >= 0 && n.x <= 1 && n.y >= 0 && n.y <= 1)){
          toastMsg.textContent = "√ùttu innan myndarinnar.";
          hideConfirm();
          tapMarker.style.display = "none";
          return;
        }

        // If already guessed => ignore taps (don‚Äôt open confirm)
        if (guessed) return;

        // Save pending + show tiny confirm near tap
        pendingGuessN = n;

        const rect = viewport.getBoundingClientRect();
        pendingTapVX = e.clientX - rect.left;
        pendingTapVY = e.clientY - rect.top;

        // Show a tiny tap marker at the tap position (optional but feels good)
        const s = imageSize();
        const tapPx = pxFromNormalized(n);
        tapMarker.style.left = tapPx.x + "px";
        tapMarker.style.top  = tapPx.y + "px";
        tapMarker.style.display = "block";

        showConfirmAt(pendingTapVX, pendingTapVY);
      }
    }
  });

  viewport.addEventListener("pointercancel", () => {
    pointers.clear();
    isPinching = false;
    isPanning = false;
    panPointerId = null;
    pendingWasClick = false;
  });

  // Wheel zoom (desktop)
  viewport.addEventListener("wheel", (e) => {
    e.preventDefault();
    const factor = e.deltaY < 0 ? 1.12 : 0.89;
    zoomAt(factor, e.clientX, e.clientY);
  }, { passive:false });

  // Buttons
  zoomIn.addEventListener("click", () => {
    const r = viewport.getBoundingClientRect();
    zoomAt(1.18, r.left + r.width/2, r.top + r.height/2);
  });
  zoomOut.addEventListener("click", () => {
    const r = viewport.getBoundingClientRect();
    zoomAt(0.85, r.left + r.width/2, r.top + r.height/2);
  });
  centerBtn.addEventListener("click", center);

  // Confirm bubble actions
  cancelGuessBtn.addEventListener("click", () => {
    hideConfirm();
    tapMarker.style.display = "none";
  });
  confirmGuessBtn.addEventListener("click", () => {
    if (!pendingGuessN) return;
    const g = pendingGuessN;
    // keep tap marker for a moment? we‚Äôll hide now
    tapMarker.style.display = "none";
    finishGuess(g);
  });

  // Clicking outside bubble closes it (but not if you click inside bubble)
  mapWrap.addEventListener("pointerdown", (e) => {
    if (!confirmBubble.classList.contains("show")) return;
    const inside = confirmBubble.contains(e.target);
    const insideViewport = viewport.contains(e.target);
    if (!inside && !insideViewport){
      hideConfirm();
      tapMarker.style.display = "none";
    }
  });

  window.addEventListener("resize", () => {
    applyTransform();
    // if bubble open, keep it clamped on resize
    if (confirmBubble.classList.contains("show")){
      showConfirmAt(pendingTapVX, pendingTapVY);
    }
  });

  // Init
  mapImg.src = MAP_SRC;
  mapImg.addEventListener("load", () => {
    const s = imageSize();
    layer.style.width = s.w + "px";
    layer.style.height = s.h + "px";
    scale = 1;
    center();
    setRound();
  });
  mapImg.addEventListener("error", () => {
    toastMsg.innerHTML = `<span class="bad">Finn ekki kortmynd:</span> <code>${MAP_SRC}</code>`;
  });
})();
</script>
</body>
</html>
